/*
** EPITECH PROJECT, 2020
** lm
** File description:
** Libmy core only header
*/

#ifndef LIB_MY_H_
#define LIB_MY_H_

#include <stdlib.h>

//////////////////////
// Output functions //
//////////////////////

/// Puts a single character in stdout
void my_putchar(char character);
/// Puts a character array in stdout
void my_putstr(char const *str);
/// Puts a character array in the file pointed by file_desc
/// \param file_desc File despcriptor (cf man 2 open)
void my_dputstr(char const *str, int file_desc);
/// Converts an int to an array of characters and prints it in stdout
void my_putnbr(long long nbr);
/// Formats a string (cf man 3 printf) and puts it in stdout
int my_printf(const char *format, ...);
/// Formats a string (cf man 3 printf) and puts it in the pointed file
/// \param file_descriptor File despcriptor (cf man 2 open)
int my_dprintf(const int file_descriptor, const char *format, ...);

//////////////////////////
// Converting functions //
//////////////////////////

/// Formats a string (cf man 3 printf) and puts it inside string. Malloc used,
/// free must be called later to avoid leaks.
/// \param string Pointer to a character array, it will be re-allocated
int my_sprintf(char **string, const char *format, ...);
/// Searchs for a number in a character array, returns it as as char array
/// \param parse Character array to be parsed
/// \param anywhere Boolean : If true, the first number found is parsed else,
/// the number must begin at parse[0]
int my_atoi(char const *parse, char anywhere);
/// Converts an integer to a character array. Malloc used, must be freed.
char *my_unatoi(int number);

/////////////////////////
// String manipulation //
/////////////////////////

/// Copies src in dest. No realloc, dest must be long enough
char *my_strcpy(char *dest, char const *src);
/// Clones src in a new character array. Malloc used, must be freed
char *my_strdup(char const *src);
/// Appends src at the end of desc. No realloc, dest must be long enough
char *my_strcat(char *dest, char const *src);
/// Appends n bytes of src at the end of desc. No realloc,
/// dest must be long enough
char *my_strncat(char *dest, char const *src, int nb);
/// Copies n bytes of src in dest. No realloc, dest must be long enough
char *my_strncpy(char *dest, char const *src, int n);
/// Clones n bytes of src in a new character array. Malloc used, must be freed
char *my_strndup(char const *src, int n);
/// Copies s1 followed by s2 in a new character array. Malloc used,
/// must be freed
char *my_strdupcat(char const *s1, char const *s2);
/// Copies s1 followed by n bytes of s2 in a new character array. Malloc used,
/// must be freed
char *my_strndupcat(char const *s1, char const *s2, int n);
/// Cuts a string at every match with delimiter
/// \param string String to be parsed
/// \param delimiter Delimiter, string will be cut arround matchs with it.
char **parse_string(char const *string, char const *delimiter);

///////////////////////////
// Raw data manipulation //
///////////////////////////

/// Replaces size bytes of ptr by 0's
void my_memset(void *pointer, size_t length);
/// Copies length bytes of src to dest
void my_memcpy(void *dest, void const *src, size_t length);

////////////////////////////
// Mathematical functions //
////////////////////////////

/// Computes nb power p
int my_power(int nb, int p);

///////////////////////////////////
// Test and evaluation functions //
///////////////////////////////////

/// Tests if s1 is identical to s2
int my_strcmp(char const *s1, char const *s2);
/// Tests if the first n bytes of s1 are identical to the first n bytes of s2
int my_strncmp(char const *s1, char const *s2, int n);
/// Calculates the length (number of characters) of nbr in base 'base_to'
int my_baselen(int nbr, int base_to);
/// Calculates the numbers of characters in str, from position 0 to terminating
/// null byte
int my_strlen(char const *str);

/////////////////////////
// Data free functions //
/////////////////////////

/// Frees a string array generated by parse_string
void free_parse_str(char **parsed_str);

#endif